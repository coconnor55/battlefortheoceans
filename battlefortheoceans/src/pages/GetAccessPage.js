// src/pages/GetAccessPage.js
// Copyright(c) 2025, Clint H. O'Connor
// v0.2.10: Only fetch price info when purchase is enabled
//          - Price fetching now checks purchaseEnabled before making API calls
//          - Prevents unnecessary network requests when purchase is disabled
//          - Stripe is only loaded when actually initiating purchase (already lazy-loaded)
// v0.2.9: Rename referral_passes to referral_email throughout
//         - Updated all references from referral_passes to referral_email
//         - referral_email = what each side gets when email invite sent/received (1)
//         - referral_signup = what each side gets when invitee signs up (10)
// v0.2.8: Refactor hooks - remove ForHooks alias variables, move key data check before hooks
//         - Removed all "ForHooks" alias variables (unnecessary duplication)
//         - Use main variables directly in hooks and callbacks
//         - Moved key data check to be right after key data definitions, before all hooks
//         - Applied same pattern to AchievementsPage, SelectEraPage, SelectOpponentPage, StatsPage
// v0.2.7: Refactor key data constants - move all to top with ForHooks variables
//         - Consolidated all key data constants and derivations at the top
//         - Removed duplicate definitions later in the file
//         - ForHooks variables are now aliases for the main constants
//         - Key data check remains in place but uses variables from top
// v0.2.6: Fix reward voucher for exclusive eras - use era voucher instead of pass voucher
//         - Changed reward voucher type from 'pass' to selectedEraId (e.g., 'pirates')
//         - Reward is now era-1 (e.g., pirates-1) instead of pass-1
//         - Matches the era being invited for (exclusive eras use era vouchers)
// v0.2.5: Only notify subscribers for pass vouchers, not era vouchers
//         - Check voucherType from redeemVoucher result before notifying
//         - Prevents NavBar from refreshing pass balance for era vouchers
//         - Era vouchers don't affect pass balance, only pass vouchers do
// v0.2.4: Fix reward voucher creation - set created_by to null for system rewards
//         - Changed reward voucher createdBy from playerIdForHooks to null
//         - Prevents "You cannot redeem a voucher that you created" error
//         - System-generated reward vouchers should not have created_by set
//         - Matches fix in VoucherService.processReferralReward
// v0.2.3: Replace key data error throwing with graceful handling
//         - Use logwarn instead of logerror and throw
//         - Call coreEngine.handleKeyDataError() to save error and navigate to Launch
//         - Return null to prevent rendering when key data is missing
// v0.2.2: Allow null playerEmail for guest users in key data check
//         - Guest users don't have email, so playerEmail check is conditional
//         - Only require playerEmail for non-guest users
// v0.2.1: Fix invite pass count - invite should be 1 pass, not 10
//         - Changed invitePasses to use referral_email (1) instead of friend_signup (10)
//         - Friend gets 1 pass/voucher in invite to try the game
//         - Friend gets 10 more passes/vouchers when they sign up (referral_signup)
//         - Updated UI text to reflect correct pass counts
// v0.2.0: Replaced feature-item cards with challenge cards in Earn section
//         - Replaced simple feature-item cards with full challenge cards matching AchievementsPage
//         - Added challenge cards with icons, progress bars, and passes badge
//         - Added condensed styling (challenge-item--condensed) for more compact layout
//         - Added helper functions getLucideIcon and getTierBadgeClass
//         - Updated achievement data structure to include current, target, percentage for progress bars
// v0.1.9: Use coreEngine.selectedEraConfig and coreEngine.gameConfig directly
//         - Remove selectedEraId prop (use coreEngine.selectedEraConfig)
//         - Remove local config loading (already loaded in CoreEngine)
//         - Remove state for selectedEraConfig and gameConfig
//         - Simpler: just read from CoreEngine
// v0.1.8: Updated to use coreEngine.gameConfig
// v0.1.7: Update emails and vouchers for referrals and sign up bonus
// v0.1.6: Fixed send-invite API call to include eraName parameter
//         - Now sends: friendEmail, senderName, senderEmail, voucherCode, eraName
//         - Voucher generated by GetAccessPage via VoucherService
//         - send-invite function sends email via Brevo and CCs sender
// v0.1.5: Removed ALL inline styles - using existing CSS classes only
//         - Replaced all style={{...}} with CSS classes from shared-components.css, utilities.css, etc.
//         - No functional changes, only styling approach
// v0.1.4: Added promotional image and description to header
//         - Promotional image displays at top (if available)
//         - Era description shows below image
//         - Sections follow: Pass/Voucher/Purchase
// v0.1.3: Fixed stripe_price_id path - use promotional.stripe_price_id
//         - Changed selectedEraConfig.stripe_price_id to selectedEraConfig.promotional.stripe_price_id
//         - Matches PurchasePage implementation exactly
// v0.1.2: Added achievement descriptions to Pass Section
//         - Display format: Name, Description (separate lines), Progress
//         - Shows what user needs to do to unlock achievement
// v0.1.1: Fixed purchase section - restored Stripe integration from PurchasePage
//         - Added priceInfo state and fetching logic
//         - Added proper Stripe checkout flow
//         - Fixed purchase availability check (stripe_price_id instead of price)
// v0.1.0: Initial GetAccessPage - unified access acquisition modal
//         Replaces PurchasePage with conditional sections:
//         - Pass Section (if era can use passes)
//         - Voucher Section (if era is exclusive)
//         - Purchase Section (always shown)

import React, { useState, useEffect, useCallback } from 'react';
import VoucherService from '../services/VoucherService';
import useInviteFlow from '../hooks/useInviteFlow';
import { supabase } from '../utils/supabaseClient';
import { coreEngine, useGame } from '../context/GameContext';
import * as LucideIcons from 'lucide-react';

const version = 'v0.2.10';
const tag = "ACCESS";
const module = "GetAccessPage";
let method = "";

const GetAccessPage = ({ onComplete, onCancel }) => {
    // Logging utilities
    const log = (message) => {
      console.log(`[${tag}] ${version} ${module}.${method} : ${message}`);
    };
    
    const logerror = (message, error = null) => {
      if (error) {
        console.error(`[${tag}] ${version} ${module}.${method}: ${message}`, error);
      } else {
        console.error(`[${tag}] ${version} ${module}.${method}: ${message}`);
      }
    };
    
    const logwarn = (message) => {
        console.warn(`[${tag}] ${version} ${module}.${method}: ${message}`);
    };

    // All hooks must be called before any conditional returns
    // Hook for invite/voucher logic
    const {
        inviteFriend,
        consumeVoucher,
        clearMessages,
        loading,
        error,
        success
    } = useInviteFlow();

    const [voucherCode, setVoucherCode] = useState('');
    
    // Price info from Stripe
    const [priceInfo, setPriceInfo] = useState(null);
    const [fetchingPrice, setFetchingPrice] = useState(false);
    
    // Achievement data (for pass section)
    const [nearestAchievements, setNearestAchievements] = useState([]);
    
    // Email friend form
    const [friendEmail, setFriendEmail] = useState('');
    const [sendingEmail, setSendingEmail] = useState(false);
    const [emailSuccess, setEmailSuccess] = useState(false);
    const [emailError, setEmailError] = useState(null);
    
    // Purchase state
    const [purchasing, setPurchasing] = useState(false);
    const [purchaseError, setPurchaseError] = useState(null);

    // Key data - see CoreEngine handle{state}
    const gameConfig = coreEngine.gameConfig;
    const eras = coreEngine.eras;
    const player = coreEngine.player;
    const playerProfile = coreEngine.playerProfile;
    const playerEmail = coreEngine.playerEmail;
    const selectedEraId = coreEngine.selectedEraId;
    const selectedEraConfig = coreEngine.selectedEraConfig;
    const selectedAlliance = coreEngine.selectedAlliance;
    const selectedOpponents = coreEngine.selectedOpponents;
    
    // Derived data
    const playerId = coreEngine.playerId;
    const playerRole = coreEngine.playerRole;
    const playerGameName = coreEngine.playerGameName;
    const isGuest = player != null && player.isGuest;
    const isAdmin = player != null && playerProfile?.isAdmin;
    const isDeveloper = player != null && playerProfile?.isDeveloper;
    const isTester = player != null && playerProfile?.isTester;
    const selectedOpponent = selectedOpponents?.[0];
    const selectedGameMode = coreEngine.selectedGameMode;
    const gameInstance = coreEngine.gameInstance;
    const board = coreEngine.board;

    // Load nearest achievements (copied from OverPage pattern)
    const loadNearestAchievements = useCallback(async () => {
        console.log(`[ACCESS] GetAccessPage ${version}| Finding nearest achievements`);
        try {
            // Fetch all achievements
            const { data: achievements, error: achError } = await supabase
                .from('achievements')
                .select('*')
                .order('requirement_value', { ascending: true });
            
            if (achError) throw achError;
            
            if (!playerId) return;
            
            // Get user's unlocked achievements
            const { data: userAchievements } = await supabase
                .from('user_achievements')
                .select('achievement_id')
                .eq('player_id', playerId)
                .eq('unlocked', true);
            
            const unlockedIds = new Set(
                userAchievements?.map(ua => ua.achievement_id) || []
            );
            
            // Get user stats for progress calculation
            const { data: stats } = await supabase
                .from('user_profiles')
                .select('total_games, total_wins, total_ships_sunk, total_damage')
                .eq('id', playerId)
                .single();
            
            // Helper functions for progress calculation
            const calculateProgress = (achievement, userStats) => {
                const reqValue = achievement.requirement_value;
                switch (achievement.requirement_type) {
                    case 'total_games':
                        return userStats.total_games || 0;
                    case 'total_wins':
                        return userStats.total_wins || 0;
                    case 'total_ships_sunk':
                        return userStats.total_ships_sunk || 0;
                    case 'total_damage':
                        return userStats.total_damage || 0;
                    default:
                        return 0;
                }
            };
            
            const calculateProgressPercent = (achievement, userStats) => {
                const progress = calculateProgress(achievement, userStats);
                const required = achievement.requirement_value;
                return Math.min(100, Math.round((progress / required) * 100));
            };
            
            // Filter unlocked and calculate progress
            const locked = achievements
                .filter(a => !unlockedIds.has(a.id) && a.reward_passes > 0)
                .map(a => {
                    const progress = calculateProgress(a, stats || {});
                    const percentage = calculateProgressPercent(a, stats || {});
                    return {
                        ...a,
                        progress,
                        progressPercent: percentage,
                        current: progress,
                        target: a.requirement_value,
                        percentage: Math.min(100, Math.round((progress / a.requirement_value) * 100))
                    };
                })
                .sort((a, b) => {
                    const aRemaining = a.requirement_value - a.progress;
                    const bRemaining = b.requirement_value - b.progress;
                    return aRemaining - bRemaining;
                });
                
            // Take top 3
            const nearest = locked.slice(0, 3);
            setNearestAchievements(nearest);
            
            console.log(`[ACCESS] GetAccessPage ${version}| Loaded ${nearest.length} nearest achievements`);
            
        } catch (err) {
            console.error(`[ACCESS] GetAccessPage ${version}| Error loading achievements:`, err);
        }
    }, [playerId]);

    // Handle email friend (pass section)
    const handleSendPassEmail = useCallback(async () => {
        if (!friendEmail || !friendEmail.includes('@')) {
            setEmailError('Please enter a valid email address');
            return;
        }
        
        const invitePasses = gameConfig?.referral_email || 1;
        const rewardPasses = gameConfig?.referral_email || 1;
        const signupBonus = gameConfig?.referral_signup || 10;
        
        try {
            setSendingEmail(true);
            setEmailError(null);
            setEmailSuccess(false);
            
            console.log(`[ACCESS] GetAccessPage ${version}| Generating pass voucher for friend`);
            
            const result = await VoucherService.findOrCreateVoucher(
                null, // eraId (null for pass vouchers)
                invitePasses,
                playerId,
                friendEmail.trim(),
                'email_pass',
                rewardPasses,
                signupBonus
            );

            const voucherCode = result.voucherCode;

            if (result.status === 'already_redeemed') {
                setEmailError('This friend has already redeemed a voucher from you.');
                return;
            }

            console.log(`[ACCESS] GetAccessPage ${version}| Voucher ${result.status}: ${voucherCode}`);
            console.log(`[ACCESS] GetAccessPage ${version}| Sending invite email to:`, friendEmail);
            
            const response = await fetch('/.netlify/functions/send-invite', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    friendEmail: friendEmail.trim(),
                    senderName: playerProfile?.game_name || 'A friend',
                    senderEmail: playerEmail,
                    voucherCode: voucherCode,
                    eraName: null // Pass voucher, no era
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || 'Failed to send email');
            }

            // Generate and auto-redeem reward voucher for sender
            console.log(`[ACCESS] GetAccessPage ${version}| Generating immediate reward for sender`);
            const rewardCode = await VoucherService.generateVoucher(
                'pass',
                rewardPasses,
                'email_immediate_reward',
                null,  // created_by = null for system rewards (not user-created)
                null,
                rewardPasses,
                0
            );
            const rewardResult = await VoucherService.redeemVoucher(coreEngine.player?.id, rewardCode);
            console.log(`[ACCESS] GetAccessPage ${version}| Sender rewarded with ${rewardPasses} pass(es)`);
            
            // Only notify for pass vouchers (reward vouchers are always pass vouchers)
            // Notify subscribers for both pass and era vouchers to refresh NavBar
            if (coreEngine && coreEngine.notifySubscribers) {
                coreEngine.notifySubscribers();
            }
            
            setEmailSuccess(true);
            setFriendEmail('');
            
            console.log(`[ACCESS] GetAccessPage ${version}| Email sent successfully`);
            
            // Close modal and refresh badges after short delay to show success message
            setTimeout(() => {
                if (onComplete) {
                    onComplete(selectedEraId);
                }
            }, 2000);
            
        } catch (err) {
            console.error(`[ACCESS] GetAccessPage ${version}| Error sending email:`, err);
            setEmailError(err.message || 'Failed to send email');
        } finally {
            setSendingEmail(false);
        }
    }, [friendEmail, playerEmail, playerProfile, gameConfig, playerId]);

    // Handle email friend (voucher section)
    const handleSendVoucherEmail = useCallback(async () => {
        if (!friendEmail || !friendEmail.includes('@')) {
            setEmailError('Please enter a valid email address');
            return;
        }
        
        try {
            setSendingEmail(true);
            setEmailError(null);
            setEmailSuccess(false);
            
            console.log(`[ACCESS] GetAccessPage ${version}| Generating ${selectedEraId} voucher for friend`);
            
            const inviteVouchers = gameConfig?.referral_email || 1;  // Friend gets 1 voucher in invite
            const rewardPasses = gameConfig?.referral_email || 1;   // Sender gets 1 voucher immediately
            const signupBonus = gameConfig?.referral_signup || 10;   // Friend gets 10 when they sign up

            const result = await VoucherService.findOrCreateVoucher(
                selectedEraId,
                inviteVouchers,
                playerId,
                friendEmail.trim(),
                'email_era',
                rewardPasses,
                signupBonus
            );

            const voucherCode = result.voucherCode;

            if (result.status === 'already_redeemed') {
                setEmailError('This friend has already redeemed a voucher from you.');
                return;
            }

            console.log(`[ACCESS] GetAccessPage ${version}| Voucher ${result.status}: ${voucherCode}`);
            console.log(`[ACCESS] GetAccessPage ${version}| Sending invite email to:`, friendEmail);
            
            const response = await fetch('/.netlify/functions/send-invite', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    friendEmail: friendEmail.trim(),
                    senderName: playerProfile?.game_name || 'A friend',
                    senderEmail: playerEmail,
                    voucherCode: voucherCode,
                    eraName: selectedEraConfig?.name
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || 'Failed to send email');
            }

            // Generate and auto-redeem reward voucher for sender
            // For exclusive eras, reward is an era voucher (e.g., pirates-1), not a pass voucher
            console.log(`[ACCESS] GetAccessPage ${version}| Generating immediate reward for sender`);
            console.log(`[ACCESS] GetAccessPage ${version}| selectedEraId:`, selectedEraId);
            console.log(`[ACCESS] GetAccessPage ${version}| selectedEraConfig:`, selectedEraConfig);
            
            // Ensure we use the era ID, not 'pass'
            // Try selectedEraId first, then selectedEraConfig.id, then selectedEraConfig.era, finally 'pass'
            const voucherType = selectedEraId || selectedEraConfig?.id || selectedEraConfig?.era || 'pass';
            console.log(`[ACCESS] GetAccessPage ${version}| Using voucher type:`, voucherType);
            
            const rewardCode = await VoucherService.generateVoucher(
                voucherType,  // Era ID (e.g., 'pirates') for exclusive eras
                1,  // 1 play for this era
                'email_immediate_reward',
                null,  // created_by = null for system rewards (not user-created)
                null,
                0,  // rewardPasses not applicable for era vouchers
                0   // signupBonus not applicable for era vouchers
            );
            const rewardResult = await VoucherService.redeemVoucher(coreEngine.player?.id, rewardCode);
            console.log(`[ACCESS] GetAccessPage ${version}| Sender rewarded with 1 play for ${selectedEraId}`);
            
            // Notify subscribers for era vouchers to refresh NavBar voucher balance
            if (coreEngine && coreEngine.notifySubscribers) {
                coreEngine.notifySubscribers();
            }
            
            setEmailSuccess(true);
            setFriendEmail('');
            
            console.log(`[ACCESS] GetAccessPage ${version}| Email sent successfully`);
            
            // Close modal and refresh badges after short delay to show success message
            setTimeout(() => {
                if (onComplete) {
                    onComplete(selectedEraId);
                }
            }, 2000);
            
        } catch (err) {
            console.error(`[ACCESS] GetAccessPage ${version}| Error sending email:`, err);
            setEmailError(err.message || 'Failed to send email');
        } finally {
            setSendingEmail(false);
        }
    }, [friendEmail, playerEmail, playerProfile, selectedEraId, selectedEraConfig, gameConfig, playerId]);

    // Handle purchase (Stripe checkout)
    const handlePurchase = useCallback(async () => {
        if (!selectedEraConfig?.promotional?.stripe_price_id) {
            setPurchaseError('This era is not available for purchase');
            return;
        }
        
        if (!playerId) {
            setPurchaseError('You must be logged in to purchase');
            return;
        }
        
        try {
            setPurchasing(true);
            setPurchaseError(null);
            
            const response = await fetch('/.netlify/functions/create_checkout_session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    priceId: selectedEraConfig.promotional.stripe_price_id,
                    playerId: playerId,
                    eraId: selectedEraId
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || 'Failed to create checkout session');
            }
            
            const { sessionId } = await response.json();
            
            // Redirect to Stripe Checkout
            const stripe = await import('@stripe/stripe-js').then(m => m.loadStripe(process.env.REACT_APP_STRIPE_PUBLISHABLE_KEY));
            const { error: stripeError } = await stripe.redirectToCheckout({ sessionId });
            
            if (stripeError) {
                throw new Error(stripeError.message);
            }
            
        } catch (err) {
            console.error(`[ACCESS] GetAccessPage ${version}| Error initiating purchase:`, err);
            setPurchaseError(err.message || 'Failed to initiate purchase');
        } finally {
            setPurchasing(false);
        }
    }, [selectedEraConfig, selectedEraId, playerId]);

    // Load era config and user email
    useEffect(() => {
        const loadData = async () => {
            try {
                // Load nearest achievements (for pass section)
                if (selectedEraConfig && !selectedEraConfig.exclusive && selectedEraConfig.passes_required > 0) {
                    await loadNearestAchievements();
                }
            } catch (err) {
                console.error(`[ACCESS] GetAccessPage ${version}| Error loading data:`, err);
            }
        };
        
        loadData();
    }, [selectedEraId, selectedEraConfig, loadNearestAchievements]);

    // Fetch price info from Stripe - only if purchase is enabled
    useEffect(() => {
        const fetchPriceInfo = async () => {
            // Check if purchase is enabled before fetching
            const purchaseEnabled = gameConfig?.purchase !== false;
            const showPurchaseSection = purchaseEnabled && selectedEraConfig?.promotional?.stripe_price_id;
            
            if (!showPurchaseSection) {
                console.log(`[ACCESS] GetAccessPage ${version}| Purchase disabled or no stripe_price_id - skipping price fetch`);
                setPriceInfo(null);
                return;
            }
            
            if (!selectedEraConfig?.promotional?.stripe_price_id) {
                console.log(`[ACCESS] GetAccessPage ${version}| No stripe_price_id for era:`, selectedEraId);
                setPriceInfo(null);
                return;
            }
            
            try {
                setFetchingPrice(true);
                console.log(`[ACCESS] GetAccessPage ${version}| Fetching price info for:`, selectedEraConfig.promotional.stripe_price_id);
                
                const response = await fetch('/.netlify/functions/get_price_info', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        priceId: selectedEraConfig.promotional.stripe_price_id
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch price information');
                }
                
                const data = await response.json();
                setPriceInfo(data);
                console.log(`[ACCESS] GetAccessPage ${version}| Price info loaded:`, data);
                
            } catch (err) {
                console.error(`[ACCESS] GetAccessPage ${version}| Error fetching price:`, err);
                setPriceInfo(null);
            } finally {
                setFetchingPrice(false);
            }
        };
        
        fetchPriceInfo();
    }, [gameConfig, selectedEraConfig, selectedEraId]);

    // Guest users should not see GetAccessPage - redirect them
    if (isGuest) {
        logwarn('Guest user attempted to access GetAccessPage - closing modal');
        if (onCancel) {
            onCancel();
        }
        return null; // Return null to prevent rendering
    }

    // Key data check - stop game if key data is missing
    // (selectedAlliance is allowed to be null)
    // (playerEmail is allowed to be null for guest users)
    const required = { gameConfig, eras, player, playerProfile, playerEmail, selectedEraId };
    const missing = Object.entries(required)
        .filter(([key, value]) => !value)
        .map(([key, value]) => `${key}=${value}`);
    if (missing.length > 0) {
        const errorMessage = `key data missing: ${missing.join(', ')}`;
        logwarn(errorMessage);
        coreEngine.handleKeyDataError('access', errorMessage);
        return null; // Return null to prevent rendering
    }

    const invitePasses = gameConfig?.referral_email || 1;  // ✅ What friend gets in invite (1 pass/voucher to try the game)
    const rewardPasses = gameConfig?.referral_email || 1;  // ✅ What sender gets immediately
    const signupBonus = gameConfig?.referral_signup || 10;  // ✅ What friend gets when they sign up

    console.log(`[ACCESS] GetAccessPage ${version}| playerId ${playerId}, name ${playerGameName}, email ${playerEmail}, gameConfig ${gameConfig}, selectedEraId ${selectedEraId}, selectedEraConfig ${selectedEraConfig}`);

  // Helper function to get Lucide icon component by name
  const getLucideIcon = (iconName) => {
    const Icon = LucideIcons[iconName];
    return Icon || LucideIcons.Award; // Fallback to Award icon
  };

  // Helper function to get tier badge class
  const getTierBadgeClass = (tier) => {
    switch (tier) {
      case 'bronze': return 'badge--bronze';
      case 'silver': return 'badge--silver';
      case 'gold': return 'badge--gold';
      case 'platinum': return 'badge--platinum';
      case 'diamond': return 'badge--diamond';
      default: return 'badge--primary';
    }
  };

    // All hooks are now at the top - no duplicates here
    
    // Handle voucher entry (not a hook, just a regular function)
    const handleEnterVoucher = async (e) => {
        e.preventDefault();
        if (!voucherCode.trim()) return;

        const result = await consumeVoucher(voucherCode);

        if (result.success) {
            setVoucherCode('');
            
            // Close modal and refresh after short delay
            setTimeout(() => {
                onComplete();
            }, 2000);
        }
    };

  // Loading state
  if (loading) {
    return (
      <div className="modal-overlay modal-overlay--transparent">
        <div className="content-pane content-pane--narrow">
          <div className="loading">
            <div className="spinner spinner--lg"></div>
            <p>Loading...</p>
          </div>
        </div>
      </div>
    );
  }

  // Error state
  if (error || !selectedEraConfig) {
    return (
      <div className="modal-overlay modal-overlay--transparent">
        <div className="content-pane content-pane--narrow">
          <div className="card-header">
            <h2 className="card-title">Error</h2>
          </div>
          <div className="card-body">
            <p className="message message--error">
              {error || 'Failed to load era information'}
            </p>
          </div>
          <div className="card-footer">
            <button className="btn btn--secondary" onClick={onCancel}>
              Close
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Determine which sections to show
  const purchaseEnabled = gameConfig?.purchase !== false; // Default to true if not set (backward compatible)
  const showPassSection = !selectedEraConfig.exclusive && selectedEraConfig.passes_required > 0;
  const showVoucherSection = selectedEraConfig.exclusive;
  const showPurchaseSection = purchaseEnabled && selectedEraConfig.promotional?.stripe_price_id;
    console.log(`[ACCESS] GetAccessPage ${version}| showPassSection ${showPassSection}, showVoucherSection ${showVoucherSection}, showPurchaseSection ${showPurchaseSection}, purchaseEnabled ${purchaseEnabled}`);

  return (
    <div className="modal-overlay modal-overlay--transparent">
      <div className="content-pane content-pane--narrow">
        
        {/* Header */}
          <div className="card-header card-header--with-close">
          <div>
          <h2 className="card-title">Get Access to {selectedEraConfig.name}</h2>
          <p className="card-subtitle">You need access to play this era</p>
          </div>
          {onCancel && (
            <button className="btn btn--secondary btn--sm" onClick={onCancel}>
              ✕
            </button>
          )}
        </div>

        <div className="card-body">
          
          {/* Promotional Image & Description (at top) */}
          {selectedEraConfig.promotional?.promotional_image && (
            <div className="promo-image-container mb-lg">
              <img
                src={`/assets/eras/${selectedEraConfig.id}/${selectedEraConfig.promotional.promotional_image}`}
                alt={selectedEraConfig.name}
                className="promo-image"
              />
            </div>
          )}
          
          {selectedEraConfig.era_description && (
            <div className="mb-lg">
              <p>{selectedEraConfig.era_description}</p>
            </div>
          )}
          
          {/* Pass Section - shown if era can use passes */}
          {showPassSection && (
            <div className="card-section">
               <div className="divider">
               </div>
              <h3>Earn</h3>
              
              {/* Nearest Achievements */}
              {nearestAchievements.length > 0 && (
                <div className="mb-lg">
                  <p>You can play this era when you earn more achievements!</p>
                  
                  <div className="challenges-section mt-md">
                    {nearestAchievements.map(achievement => {
                      const Icon = getLucideIcon(achievement.badge_icon);
                      return (
                        <div
                          key={achievement.id}
                          className="challenge-item challenge-item--condensed"
                        >
                          {achievement.reward_passes > 0 && (
                            <div className="challenge-passes-badge">
                              +{achievement.reward_passes} Passes
                            </div>
                          )}
                          <div className="challenge-header">
                            <div className="challenge-icon">
                              <Icon size={24} />
                            </div>
                            <div className="challenge-info">
                              <div className="challenge-name">
                                {achievement.name}
                                <span className={`badge ${getTierBadgeClass(achievement.tier)} ml-sm`}>
                                  {achievement.points} pts
                                </span>
                              </div>
                              <div className="challenge-description">{achievement.description}</div>
                            </div>
                          </div>
                          <div className="challenge-progress">
                            <div className="progress-bar">
                              <div
                                className="progress-bar__fill"
                                style={{ width: `${achievement.percentage || 0}%` }}
                              ></div>
                            </div>
                            <div className="progress-text">
                              {achievement.current || 0} / {achievement.target} ({achievement.percentage || 0}%)
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              
              {/* Email Friend for Passes */}
               <div className="divider">
               </div>
               <h3>Invite</h3>
              <div className="card-section">
                <p className="mb-lg">
                  <strong>Or get a pass immediately! </strong>
                  You can play this era by inviting a new friend to try!
                  </p>
                <p className="text-secondary mb-md">
                Earn 1 pass immediately, plus 10 more when your friend signs up
                (your friend gets 1 pass to try the game, then 10 more when they sign up). 
                You'll be copied on the email so you can follow up with a personal message if you choose.                
                </p>
                
                {emailSuccess && (
                  <div className="message message--success mb-md">
                    Email sent successfully! Check your inbox for a copy.
                  </div>
                )}
                
                {emailError && (
                  <div className="message message--error mb-md">
                    {emailError}
                  </div>
                )}
                
                <div className="flex gap-sm">
                  <input
                    type="email"
                    className="input"
                    placeholder="Friend's email address"
                    value={friendEmail}
                    onChange={(e) => setFriendEmail(e.target.value)}
                    disabled={sendingEmail}
                  />
                  <button
                    className="btn btn--primary"
                    onClick={handleSendPassEmail}
                    disabled={sendingEmail || !friendEmail}
                  >
                    {sendingEmail ? 'Sending...' : 'Send'}
                  </button>
                </div>
                               
               {/* Manual Voucher Entry */}
               <div className="form-group"><p />
                 <p><strong>Already have a voucher?</strong></p>
                 <form onSubmit={handleEnterVoucher} style={{ display: 'flex', gap: '0.5rem' }}>
                   <input
                     type="text"
                     className="form-input"
                     value={voucherCode}
                     onChange={(e) => setVoucherCode(e.target.value)}
                     placeholder="Cut and paste or input voucher code"
                     disabled={loading}
                     style={{ flex: 1 }}
                   />
                   <button
                     type="submit"
                     className="btn btn--primary"
                     disabled={loading || !voucherCode.trim()}
                   >
                     {loading ? 'Redeeming...' : 'Enter'}
                   </button>
                 </form>
               </div>
              </div>
            </div>
          )}

          {/* Voucher Section - shown if era is exclusive */}
          {showVoucherSection && (
            <div className="card-section">
              <h3>Invite</h3>
              
              <div className="info-card">
                <p className="mb-md">
                You can play this era by inviting a new friend to try!
                </p>
                <p className="text-secondary mb-md">
                Earn 1 play immediately, plus 10 more when your friend signs up
                (your friend gets 1 play to try the game, then 10 more when they sign up). 
                You'll be copied on the email so you can follow up with a personal message if you choose.
                </p>
                
                {emailSuccess && (
                  <div className="message message--success mb-md">
                    Email sent successfully! Check your inbox for a copy.
                  </div>
                )}
                
                {emailError && (
                  <div className="message message--error mb-md">
                    {emailError}
                  </div>
                )}
                
                <div className="flex gap-sm">
                  <input
                    type="email"
                    className="input"
                    placeholder="Friend's email address"
                    value={friendEmail}
                    onChange={(e) => setFriendEmail(e.target.value)}
                    disabled={sendingEmail}
                  />
                  <button
                    className="btn btn--primary"
                    onClick={handleSendVoucherEmail}
                    disabled={sendingEmail || !friendEmail}
                  >
                    {sendingEmail ? 'Sending...' : 'Send'}
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Purchase Section - shown only if purchase is enabled in game-config.json */}
          {showPurchaseSection && (
            <>
              <div className="divider">
                <span>Purchase</span>
              </div>
              <div className="card-section">
                <h3>Purchase Premium Access</h3>
                
                <div className="feature-grid">
                  <div className="feature-item">
                    <strong>✅ One-time purchase</strong>
                    <p>Unlimited plays - immediately and forever</p>
                  </div>
                  <div className="feature-item">
                    <strong>✅ Support development</strong>
                    <p>Help me create more amazing eras</p>
                  </div>
                </div>
                
                {selectedEraConfig.promotional?.stripe_price_id ? (
                  <div className="text-center mt-md">
                    {fetchingPrice ? (
                      <div className="loading">
                        <div className="spinner spinner--sm"></div>
                        <p>Loading price...</p>
                      </div>
                    ) : priceInfo ? (
                      <>
                        <div className="price-display">
                          <span className="price-amount">${(priceInfo.unit_amount / 100).toFixed(2)}</span>
                        </div>
                        
                        {purchaseError && (
                          <div className="message message--error mt-md">
                            {purchaseError}
                          </div>
                        )}
                        
                        <button
                          className="btn btn--primary btn--lg mt-md"
                          onClick={handlePurchase}
                          disabled={purchasing}
                        >
                          {purchasing ? 'Processing...' : `Purchase ${selectedEraConfig.name}`}
                        </button>
                      </>
                    ) : (
                      <p className="text-dim">
                        Price information unavailable
                      </p>
                    )}
                  </div>
                ) : (
                  <p className="text-center text-dim mt-md">
                    This era is not available for direct purchase.
                  </p>
                )}
              </div>
            </>
          )}

        </div>

        {/* Footer */}
        <div className="card-footer">
          <button className="btn btn--secondary" onClick={onCancel}>
            Close
          </button>
        </div>

      </div>
    </div>
  );
};

export default GetAccessPage;

// EOF
