// src/pages/GetAccessPage.js
// Copyright(c) 2025, Clint H. O'Connor
// v0.1.9: Use coreEngine.selectedEraConfig and coreEngine.gameConfig directly
//         - Remove eraId prop (use coreEngine.selectedEraConfig)
//         - Remove local config loading (already loaded in CoreEngine)
//         - Remove state for eraConfig and gameConfig
//         - Simpler: just read from CoreEngine
// v0.1.8: Updated to use coreEngine.gameConfig
// v0.1.7: Update emails and vouchers for referrals and sign up bonus
// v0.1.6: Fixed send-invite API call to include eraName parameter
//         - Now sends: friendEmail, senderName, senderEmail, voucherCode, eraName
//         - Voucher generated by GetAccessPage via VoucherService
//         - send-invite function sends email via Brevo and CCs sender
// v0.1.5: Removed ALL inline styles - using existing CSS classes only
//         - Replaced all style={{...}} with CSS classes from shared-components.css, utilities.css, etc.
//         - No functional changes, only styling approach
// v0.1.4: Added promotional image and description to header
//         - Promotional image displays at top (if available)
//         - Era description shows below image
//         - Sections follow: Pass/Voucher/Purchase
// v0.1.3: Fixed stripe_price_id path - use promotional.stripe_price_id
//         - Changed eraConfig.stripe_price_id to eraConfig.promotional.stripe_price_id
//         - Matches PurchasePage implementation exactly
// v0.1.2: Added achievement descriptions to Pass Section
//         - Display format: Name, Description (separate lines), Progress
//         - Shows what user needs to do to unlock achievement
// v0.1.1: Fixed purchase section - restored Stripe integration from PurchasePage
//         - Added priceInfo state and fetching logic
//         - Added proper Stripe checkout flow
//         - Fixed purchase availability check (stripe_price_id instead of price)
// v0.1.0: Initial GetAccessPage - unified access acquisition modal
//         Replaces PurchasePage with conditional sections:
//         - Pass Section (if era can use passes)
//         - Voucher Section (if era is exclusive)
//         - Purchase Section (always shown)

import React, { useState, useEffect, useCallback } from 'react';
import VoucherService from '../services/VoucherService';
import useInviteFlow from '../hooks/useInviteFlow';
import { supabase } from '../utils/supabaseClient';
import { coreEngine, useGame } from '../context/GameContext';

const version = 'v0.1.9';

const GetAccessPage = ({ onComplete, onCancel }) => {
    
    // Hook for invite/voucher logic
    const {
      inviteFriend,
      consumeVoucher,
      clearMessages,
      loading,
      error,
      success
    } = useInviteFlow();

  // key data
    const playerProfile = coreEngine.playerProfile;
    const gameConfig = coreEngine.gameConfig;
    const userEmail = coreEngine.userEmail;

    const selectedEraId = coreEngine.selectedEraId;
    const eraConfig = coreEngine.selectedEraConfig;
    const eraId = eraConfig?.id;
    const playerId = playerProfile?.id;
    const playerGameName = coreEngine.playerGameName;
    const friendPasses = gameConfig?.friend_signup || 10;  // ✅ What friend gets
    const rewardPasses = gameConfig?.referral_passes || 1;
    const signupBonus = gameConfig?.referral_signup || 10;

    console.log(`[ACCESS] GetAccessPage ${version}| playerId ${playerId}, name ${playerGameName}, email ${userEmail}, gameConfig ${gameConfig}, selectedEraId ${selectedEraId}, eraConfig ${eraConfig}`);

    const [voucherCode, setVoucherCode] = useState('');
    
  // Price info from Stripe
  const [priceInfo, setPriceInfo] = useState(null);
  const [fetchingPrice, setFetchingPrice] = useState(false);
  
  // Achievement data (for pass section)
  const [nearestAchievements, setNearestAchievements] = useState([]);
  
  // Email friend form
  const [friendEmail, setFriendEmail] = useState('');
  const [sendingEmail, setSendingEmail] = useState(false);
  const [emailSuccess, setEmailSuccess] = useState(false);
  const [emailError, setEmailError] = useState(null);
  
  // Purchase state
  const [purchasing, setPurchasing] = useState(false);
  const [purchaseError, setPurchaseError] = useState(null);

    // Load era config and user email
    useEffect(() => {
      const loadData = async () => {
        try {
          // Load nearest achievements (for pass section)
          if (eraConfig && !eraConfig.exclusive && eraConfig.passes_required > 0) {
            await loadNearestAchievements();
          }
        } catch (err) {
            console.error(`[ACCESS] GetAccessPage ${version}| Error loading data:`, err);
        }
      };
      
      loadData();
    }, [eraId]);

    // Fetch price info from Stripe
  useEffect(() => {
    const fetchPriceInfo = async () => {
      if (!eraConfig?.promotional?.stripe_price_id) {
        console.log(`[ACCESS] GetAccessPage ${version}| No stripe_price_id for era:`, eraId);
        setPriceInfo(null);
        return;
      }
      
      try {
        setFetchingPrice(true);
        console.log(`[ACCESS] GetAccessPage ${version}| Fetching price info for:`, eraConfig.promotional.stripe_price_id);
        
        const response = await fetch('/.netlify/functions/get_price_info', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            priceId: eraConfig.promotional.stripe_price_id
          })
        });
        
        if (!response.ok) {
          throw new Error('Failed to fetch price information');
        }
        
        const data = await response.json();
        setPriceInfo(data);
        console.log(`[ACCESS] GetAccessPage ${version}| Price info loaded:`, data);
        
      } catch (err) {
        console.error(`[ACCESS] GetAccessPage ${version}| Error fetching price:`, err);
        setPriceInfo(null);
      } finally {
        setFetchingPrice(false);
      }
    };
    
    fetchPriceInfo();
  }, [eraConfig, eraId]);

  // Load nearest achievements (copied from OverPage pattern)
  const loadNearestAchievements = useCallback(async () => {
      console.log(`[ACCESS] GetAccessPage ${version}| Finding nearest achievements`);
    try {
      // Fetch all achievements
      const { data: achievements, error: achError } = await supabase
        .from('achievements')
        .select('*')
        .order('requirement_value', { ascending: true });
      
      if (achError) throw achError;
      
      // Get user's unlocked achievements
      const { data: userAchievements } = await supabase
        .from('user_achievements')
        .select('achievement_id')
        .eq('player_id', playerId)
        .eq('unlocked', true);
      
      const unlockedIds = new Set(
        userAchievements?.map(ua => ua.achievement_id) || []
      );
      
      // Get user stats for progress calculation
      const { data: stats } = await supabase
        .from('user_profiles')
        .select('total_games, total_wins, total_ships_sunk, total_damage')
        .eq('id', playerId)
        .single();
      
      // Filter unlocked and calculate progress
      const locked = achievements
        .filter(a => !unlockedIds.has(a.id) && a.reward_passes > 0)
        .map(a => ({
          ...a,
          progress: calculateProgress(a, stats || {}),
          progressPercent: calculateProgressPercent(a, stats || {})
        }))
        .sort((a, b) => {
          // Calculate remaining needed for each
          const aRemaining = a.requirement_value - a.progress;
          const bRemaining = b.requirement_value - b.progress;
          // Sort by LOWEST remaining (easiest first)
          return aRemaining - bRemaining;
        });
        
      // Take top 3
      const nearest = locked.slice(0, 3);
      setNearestAchievements(nearest);
      
      console.log(`[ACCESS] GetAccessPage ${version}| Loaded ${nearest.length} nearest achievements`);
      
    } catch (err) {
      console.error(`[ACCESS] GetAccessPage ${version}| Error loading achievements:`, err);
    }
  }, [playerId]);

  // Calculate achievement progress (from OverPage)
  const calculateProgress = (achievement, userStats) => {
    const reqValue = achievement.requirement_value;
    
    switch (achievement.requirement_type) {
      case 'total_games':
        return userStats.total_games || 0;
      case 'total_wins':
        return userStats.total_wins || 0;
      case 'total_ships_sunk':
        return userStats.total_ships_sunk || 0;
      case 'total_damage':
        return userStats.total_damage || 0;
      default:
        return 0;
    }
  };

  // Calculate progress percentage
  const calculateProgressPercent = (achievement, userStats) => {
    const progress = calculateProgress(achievement, userStats);
    const required = achievement.requirement_value;
    return Math.min(100, Math.round((progress / required) * 100));
  };

  // Handle email friend (pass section)
  const handleSendPassEmail = useCallback(async () => {
    if (!friendEmail || !friendEmail.includes('@')) {
      setEmailError('Please enter a valid email address');
      return;
    }
    
    try {
      setSendingEmail(true);
      setEmailError(null);
      setEmailSuccess(false);
      
      console.log(`[ACCESS] GetAccessPage ${version}| Generating pass voucher for friend`);
      
      // Generate pass voucher (10 passes)
        // Find or create voucher with tracking
        // Find or create voucher with tracking

        const result = await VoucherService.findOrCreateVoucher(
          'pass',
          friendPasses,
          playerId,
          friendEmail.trim(),
          'email_pass',
          rewardPasses,
          signupBonus
        );
        const voucherCode = result.voucherCode;

        // Check result status
        if (result.status === 'already_redeemed') {
          setEmailError('This friend has already redeemed a voucher from you.');
          return;
        }

        console.log(`[ACCESS] GetAccessPage ${version}| Voucher ${result.status}: ${voucherCode}`);

      // Call Netlify function
      const response = await fetch('/.netlify/functions/send-invite', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          friendEmail: friendEmail.trim(),
          senderName: playerProfile?.game_name || 'A friend',
          senderEmail: userEmail,
          voucherCode: voucherCode,
          eraName: 'Battle for the Oceans' // Generic name for pass vouchers
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || 'Failed to send email');
      }
      
        // ✅ ADD THIS SECTION:
        // Generate and auto-redeem reward voucher for sender (immediate reward)
        console.log(`[ACCESS] GetAccessPage ${version}| Generating immediate reward for sender`);
        const rewardCode = await VoucherService.generateVoucher('pass', rewardPasses, 'email_immediate_reward');
        await VoucherService.redeemVoucher(coreEngine.player.id, rewardCode);
        console.log(`[ACCESS] GetAccessPage ${version}| Sender rewarded with ${rewardPasses} pass(es)`);

        setEmailSuccess(true);
      setFriendEmail('');
      
      console.log(`[ACCESS] GetAccessPage ${version}| Email sent successfully`);
      
    } catch (err) {
      console.error(`[ACCESS] GetAccessPage ${version}| Error sending email:`, err);
      setEmailError(err.message || 'Failed to send email');
    } finally {
      setSendingEmail(false);
    }
  }, [friendEmail, userEmail, playerProfile, rewardPasses, signupBonus]);

  // Handle email friend (voucher section)
  const handleSendVoucherEmail = useCallback(async () => {
    if (!friendEmail || !friendEmail.includes('@')) {
      setEmailError('Please enter a valid email address');
      return;
    }
    
    try {
      setSendingEmail(true);
      setEmailError(null);
      setEmailSuccess(false);
      
      console.log(`[ACCESS] GetAccessPage ${version}| Generating ${eraId} voucher for friend`);
      
        // Find or create voucher with tracking
        const friendPasses = gameConfig?.friend_signup || 10;  // ✅ What friend gets
        const rewardPasses = gameConfig?.referral_passes || 1;
        const signupBonus = gameConfig?.referral_signup || 10;

        const result = await VoucherService.findOrCreateVoucher(
          eraId,
          friendPasses,
          playerId,
          friendEmail.trim(),
          'email_era',
          rewardPasses,
          signupBonus
        );

        const voucherCode = result.voucherCode;

        // Check result status
        if (result.status === 'already_redeemed') {
          setEmailError('This friend has already redeemed a voucher from you.');
          return;
        }

        console.log(`[ACCESS] GetAccessPage ${version}| Voucher ${result.status}: ${voucherCode}`);
      console.log(`[ACCESS] GetAccessPage ${version}| Sending invite email to:`, friendEmail);
      
      // Call Netlify function
      const response = await fetch('/.netlify/functions/send-invite', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          friendEmail: friendEmail.trim(),
          senderName: playerProfile?.game_name || 'A friend',
          senderEmail: userEmail,
          voucherCode: voucherCode,
          eraName: eraConfig.name // Use actual era name from config
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || 'Failed to send email');
      }

        // ✅ ADD THIS SECTION:
        // Generate and auto-redeem reward voucher for sender (immediate reward)
        console.log(`[ACCESS] GetAccessPage ${version}| Generating immediate reward for sender`);
        const rewardCode = await VoucherService.generateVoucher(
          'pass',
          rewardPasses,
          'email_immediate_reward',
          playerId,           // createdBy (the person being rewarded)
          null,             // emailSentTo (not sent to anyone, auto-redeemed)
          rewardPasses,     // rewardPasses (same as value)
          0                 // signupBonusPasses (0 for reward vouchers)
        );
        await VoucherService.redeemVoucher(coreEngine.player.id, rewardCode);
        console.log(`[ACCESS] GetAccessPage ${version}| Sender rewarded with ${rewardPasses} pass(es)`);

        
      setEmailSuccess(true);
      setFriendEmail('');
      
      console.log(`[ACCESS] GetAccessPage ${version}| Email sent successfully`);
      
    } catch (err) {
      console.error(`[ACCESS] GetAccessPage ${version}| Error sending email:`, err);
      setEmailError(err.message || 'Failed to send email');
    } finally {
      setSendingEmail(false);
    }
  }, [friendEmail, userEmail, playerProfile, eraId, eraConfig]);

    // Handle voucher entry
    const handleEnterVoucher = async (e) => {
      e.preventDefault();
      if (!voucherCode.trim()) return;

      const result = await consumeVoucher(voucherCode);

      if (result.success) {
        setVoucherCode('');
        
        // Close modal and refresh after short delay
        setTimeout(() => {
          onComplete();
        }, 2000);
      }
    };

  // Handle purchase (Stripe checkout)
  const handlePurchase = useCallback(async () => {
    if (!eraConfig?.promotional?.stripe_price_id) {
      setPurchaseError('This era is not available for purchase');
      return;
    }
    
    if (!playerId) {
      setPurchaseError('You must be logged in to purchase');
      return;
    }
    
    try {
      setPurchasing(true);
      setPurchaseError(null);
      
      console.log(`[ACCESS] GetAccessPage ${version}| Creating Stripe checkout session`);
      
      const response = await fetch('/.netlify/functions/create_payment_intent', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          priceId: eraConfig.promotional.stripe_price_id,
          playerId: playerId,
          eraId: eraConfig.id
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || 'Failed to create checkout session');
      }
      
      const { checkoutUrl } = await response.json();
      
      console.log(`[ACCESS] GetAccessPage ${version}| Redirecting to Stripe checkout`);
      
      // Redirect to Stripe checkout
      window.location.href = checkoutUrl;
      
    } catch (err) {
      console.error(`[ACCESS] GetAccessPage ${version}| Purchase error:`, err);
      setPurchaseError(err.message || 'Failed to start checkout');
      setPurchasing(false);
    }
  }, [eraConfig, playerId]);

  // Loading state
  if (loading) {
    return (
      <div className="modal-overlay modal-overlay--transparent">
        <div className="content-pane content-pane--narrow">
          <div className="loading">
            <div className="spinner spinner--lg"></div>
            <p>Loading...</p>
          </div>
        </div>
      </div>
    );
  }

  // Error state
  if (error || !eraConfig) {
    return (
      <div className="modal-overlay modal-overlay--transparent">
        <div className="content-pane content-pane--narrow">
          <div className="card-header">
            <h2 className="card-title">Error</h2>
          </div>
          <div className="card-body">
            <p className="message message--error">
              {error || 'Failed to load era information'}
            </p>
          </div>
          <div className="card-footer">
            <button className="btn btn--secondary" onClick={onCancel}>
              Close
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Determine which sections to show
    
  const showPassSection = !eraConfig.exclusive && eraConfig.passes_required > 0;
  const showVoucherSection = eraConfig.exclusive;
    console.log(`[ACCESS] GetAccessPage ${version}| showPassSection ${showPassSection}, showVoucherSection ${showVoucherSection}, eraConfig ${eraConfig}`);

  return (
    <div className="modal-overlay modal-overlay--transparent">
      <div className="content-pane content-pane--narrow">
        
        {/* Header */}
          <div className="card-header card-header--with-close">
          <div>
          <h2 className="card-title">Get Access to {eraConfig.name}</h2>
          <p className="card-subtitle">You need access to play this era</p>
          </div>
          {onCancel && (
            <button className="btn btn--secondary btn--sm" onClick={onCancel}>
              ✕
            </button>
          )}
        </div>

        <div className="card-body">
          
          {/* Promotional Image & Description (at top) */}
          {eraConfig.promotional?.promotional_image && (
            <div className="promo-image-container mb-lg">
              <img
                src={`/assets/eras/${eraConfig.id}/${eraConfig.promotional.promotional_image}`}
                alt={eraConfig.name}
                className="promo-image"
              />
            </div>
          )}
          
          {eraConfig.era_description && (
            <div className="mb-lg">
              <p>{eraConfig.era_description}</p>
            </div>
          )}
          
          {/* Pass Section - shown if era can use passes */}
          {showPassSection && (
            <div className="card-section">
               <div className="divider">
               </div>
              <h3>Earn</h3>
              
              {/* Nearest Achievements */}
              {nearestAchievements.length > 0 && (
                <div className="mb-lg">
                  <p>You can play this era when you earn more achievements!</p>
                  
                  <div className="feature-grid mt-md">
                    {nearestAchievements.map(achievement => (
                      <div key={achievement.id} className="feature-item">
                        <div className="flex flex-between mb-xs">
                          <strong>{achievement.name}</strong>
                          <span className="badge badge-info">{achievement.reward_passes} passes</span>
                        </div>
                        <p className="text-secondary mb-xs">
                          {achievement.description}
                        </p>
                         <div className="text-dim">
                           {(() => {
                             const remaining = achievement.requirement_value - achievement.progress;
                             const unit = achievement.requirement_type.replace('total_', '').replace('_', ' ');
                             return `${remaining} more ${unit} needed (${achievement.progress}/${achievement.requirement_value})`;
                           })()}
                         </div>
                    </div>
                    ))}
                  </div>
                </div>
              )}
              
              {/* Email Friend for Passes */}
               <div className="divider">
               </div>
               <h3>Invite</h3>
              <div className="card-section">
                <p className="mb-lg">
                  <strong>Or get a pass immediately!</strong>
                </p>
                <p className="text-secondary mb-md">
                  Email a friend about this game. Earn 10 more passes when your friend signs up for an account
                  (your friend also gets 10 passes). You'll be copied on the email as well.
                </p>
                
                {emailSuccess && (
                  <div className="message message--success mb-md">
                    Email sent successfully! Check your inbox for a copy.
                  </div>
                )}
                
                {emailError && (
                  <div className="message message--error mb-md">
                    {emailError}
                  </div>
                )}
                
                <div className="flex gap-sm">
                  <input
                    type="email"
                    className="input"
                    placeholder="Friend's email address"
                    value={friendEmail}
                    onChange={(e) => setFriendEmail(e.target.value)}
                    disabled={sendingEmail}
                  />
                  <button
                    className="btn btn--primary"
                    onClick={handleSendPassEmail}
                    disabled={sendingEmail || !friendEmail}
                  >
                    {sendingEmail ? 'Sending...' : 'Send'}
                  </button>
                </div>
                               
               {/* Manual Voucher Entry */}
               <div className="form-group"><p />
                 <p><strong>Already have a voucher?</strong></p>
                 <form onSubmit={handleEnterVoucher} style={{ display: 'flex', gap: '0.5rem' }}>
                   <input
                     type="text"
                     className="form-input"
                     value={voucherCode}
                     onChange={(e) => setVoucherCode(e.target.value)}
                     placeholder="Cut and paste or input voucher code"
                     disabled={loading}
                     style={{ flex: 1 }}
                   />
                   <button
                     type="submit"
                     className="btn btn--primary"
                     disabled={loading || !voucherCode.trim()}
                   >
                     {loading ? 'Redeeming...' : 'Enter'}
                   </button>
                 </form>
               </div>
              </div>
            </div>
          )}

          {/* Voucher Section - shown if era is exclusive */}
          {showVoucherSection && (
            <div className="card-section">
              <h3>Get Vouchers</h3>
              
              <div className="info-card">
                <p className="mb-md">
                  You can play this era by emailing a friend about this game!
                </p>
                <p className="text-secondary mb-md">
                  Earn 10 more plays when your friend signs up for an account
                  (your friend also gets 10 plays). You'll be copied on the email as well.
                </p>
                
                {emailSuccess && (
                  <div className="message message--success mb-md">
                    Email sent successfully! Check your inbox for a copy.
                  </div>
                )}
                
                {emailError && (
                  <div className="message message--error mb-md">
                    {emailError}
                  </div>
                )}
                
                <div className="flex gap-sm">
                  <input
                    type="email"
                    className="input"
                    placeholder="Friend's email address"
                    value={friendEmail}
                    onChange={(e) => setFriendEmail(e.target.value)}
                    disabled={sendingEmail}
                  />
                  <button
                    className="btn btn--primary"
                    onClick={handleSendVoucherEmail}
                    disabled={sendingEmail || !friendEmail}
                  >
                    {sendingEmail ? 'Sending...' : 'Send'}
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Purchase Section - always shown */}
          <div className="divider">
            <span>Purchase</span>
          </div>
          <div className="card-section">
            <h3>Purchase Premium Access</h3>
            
            <div className="feature-grid">
              <div className="feature-item">
                <strong>✅ One-time purchase</strong>
                <p>Unlimited plays - immediately and forever</p>
              </div>
              <div className="feature-item">
                <strong>✅ Support development</strong>
                <p>Help me create more amazing eras</p>
              </div>
            </div>
            
            {eraConfig.promotional?.stripe_price_id ? (
              <div className="text-center mt-md">
                {fetchingPrice ? (
                  <div className="loading">
                    <div className="spinner spinner--sm"></div>
                    <p>Loading price...</p>
                  </div>
                ) : priceInfo ? (
                  <>
                    <div className="price-display">
                      <span className="price-amount">${(priceInfo.unit_amount / 100).toFixed(2)}</span>
                    </div>
                    
                    {purchaseError && (
                      <div className="message message--error mt-md">
                        {purchaseError}
                      </div>
                    )}
                    
                    <button
                      className="btn btn--primary btn--lg mt-md"
                      onClick={handlePurchase}
                      disabled={purchasing}
                    >
                      {purchasing ? 'Processing...' : `Purchase ${eraConfig.name}`}
                    </button>
                  </>
                ) : (
                  <p className="text-dim">
                    Price information unavailable
                  </p>
                )}
              </div>
            ) : (
              <p className="text-center text-dim mt-md">
                This era is not available for direct purchase.
              </p>
            )}
          </div>

        </div>

        {/* Footer */}
        <div className="card-footer">
          <button className="btn btn--secondary" onClick={onCancel}>
            Close
          </button>
        </div>

      </div>
    </div>
  );
};

export default GetAccessPage;

// EOF
